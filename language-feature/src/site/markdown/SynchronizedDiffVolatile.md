# Synchronized 和 volatile区别


## volatile 

volatile原理是基于CPU内存屏障指令实现的。

## synchronized

synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。


## 支撑Java内存模型的基础原理

### 指令重排序

> 在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。

> * 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
> * 指令级并行的重排序：如果不存l在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
> * 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

#### 数据依赖性

如果两个操作访问同一个变量，其中一个为写操作，此时这两个操作之间存在数据依赖性。 
编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序。

#### as-if-serial

不管怎么重排序，单线程下的执行结果不能被改变，编译器、runtime和处理器都必须遵守as-if-serial语义。

### 内存屏障

> 上面讲到了，通过内存屏障可以禁止特定类型处理器的重排序，从而让程序按我们预想的流程去执行。内存屏障，又称内存栅栏，是一个CPU指令，基本上它是一条这样的指令：

> * 保证特定操作的执行顺序。
> * 影响某些数据（或则是某条指令的执行结果）的内存可见性。
> * 编译器和CPU能够重排序指令，保证最终相同的结果，尝试优化性能。插入一条Memory Barrier会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。

> Memory Barrier所做的另外一件事是强制刷出各种CPU cache，如一个Write-Barrier（写入屏障）将刷出所有在Barrier之前写入 cache 的数据，因此，任何CPU上的线程都能读取到这些数据的最新版本。

> 这和java有什么关系？上面java内存模型中讲到的volatile是基于Memory Barrier实现的。

> 如果一个变量是volatile修饰的，JMM会在写入这个字段之后插进一个Write-Barrier指令，并在读这个字段之前插入一个Read-Barrier指令。这意味着，如果写入一个volatile变量，就可以保证：

一个线程写入变量a后，任何线程访问该变量都会拿到最新值。
在写入变量a之前的写入操作，其更新的数据对于其他线程也是可见的。因为Memory Barrier会刷出cache中的所有先前的写入。

#### happens-before

> 从jdk5开始，java使用新的JSR-133内存模型，基于happens-before的概念来阐述操作之间的内存可见性。

> 在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系，这个的两个操作既可以在同一个线程，也可以在不同的两个线程中。

> 与程序员密切相关的happens-before规则如下：

> * 程序顺序规则：一个线程中的每个操作，happens-before于该线程中任意的后续操作。
> * 监视器锁规则：对一个锁的解锁操作，happens-before于随后对这个锁的加锁操作。
> * volatile域规则：对一个volatile域的写操作，happens-before于任意线程后续对这个volatile域的读。
> * 传递性规则：如果 A happens-before B，且 B happens-before C，那么A happens-before C。
> * 注意：两个操作之间具有happens-before关系，并不意味前一个操作必须要在后一个操作之前执行！仅仅要求前一个操作的执行结果，对于后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。

## 区别

> * volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； 
synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
> * volatile仅能使用在变量级别；
synchronized则可以使用在变量、方法、和类级别的
> * volatile仅能实现变量的修改可见性，不能保证原子性；
而synchronized则可以保证变量的修改可见性和原子性
> * volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
> * volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化