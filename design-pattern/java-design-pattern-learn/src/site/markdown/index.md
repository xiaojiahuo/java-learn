# 设计模式 学习

参考[菜鸟教程-设计模式](http://www.runoob.com/design-pattern/design-pattern-intro.html)

## 0 [UML基础](uml.md)

## 1 设计模式简介

> 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。
这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
  
> 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。
使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 
毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，
设计模式是软件工程的基石，如同大厦的一块块砖石一样。
项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，
每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。

### 什么是 GOF（四人帮，全拼 Gang of Four）？

>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。
四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。
* 对接口编程而不是对实现编程
* 优先使用对象组合而不是继承

### 设计模式的使用
设计模式在软件开发中的两个主要用途。
* #### 开发人员的共同平台
> 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。
* #### 最佳的实践
> 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。

## 2 设计模式分类

> 根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，
总共有 23 种设计模式。
这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
当然，我们还会讨论另一类设计模式：J2EE 设计模式。

模式&描述 | 包括
--- | ---
**创建型模式**<br/>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，<br/>而不是使用 new 运算符直接实例化对象。<br/>这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。| [工厂模式（Factory Pattern）](factory.md)<br/>[抽象工厂模式（Abstract Factory Pattern）](abstract-factory.md)<br/>[单例模式（Singleton Pattern）](singleton.md)<br/>[建造者模式（Builder Pattern）]()<br/>原型模式（Prototype Pattern） 
**结构型模式**<br/>这些设计模式关注类和对象的组合。<br/>继承的概念被用来组合接口和定义组合对象获得新功能的方式。| 适配器模式（Adapter Pattern）<br/>桥接模式（Bridge Pattern）<br/>过滤器模式（Filter、Criteria Pattern）<br/>组合模式（Composite Pattern）<br/>装饰器模式（Decorator Pattern）<br/>外观模式（Facade Pattern）<br/>享元模式（Flyweight Pattern）<br/>代理模式（Proxy Pattern） 
**行为型模式**<br/>这些设计模式特别关注对象之间的通信。| 责任链模式（Chain of Responsibility Pattern）<br/>命令模式（Command Pattern）<br/>解释器模式（Interpreter Pattern）<br/>迭代器模式（Iterator Pattern）<br/>中介者模式（Mediator Pattern）<br/>备忘录模式（Memento Pattern）<br/>观察者模式（Observer Pattern）<br/>状态模式（State Pattern）<br/>空对象模式（Null Object Pattern）<br/>策略模式（Strategy Pattern）<br/>模板模式（Template Pattern）<br/>访问者模式（Visitor Pattern）
**J2EE 模式**<br/>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。| MVC 模式（MVC Pattern）<br/>业务代表模式（Business Delegate Pattern）<br/>组合实体模式（Composite Entity Pattern）<br/>数据访问对象模式（Data Access Object Pattern）<br/>前端控制器模式（Front Controller Pattern）<br/>拦截过滤器模式（Intercepting Filter Pattern）<br/>服务定位器模式（Service Locator Pattern）<br/>传输对象模式（Transfer Object Pattern）

## 3 设计模式六大原则

原则 | 简述
---|---
开闭原则 | 实现热插拔，提高扩展性
里氏代换原则 | 实现抽象的规范，实现子父类互相替换
依赖倒置原则 | 针对接口编程，实现开闭原则的基础
接口隔离原则 | 降低耦合度，接口单独设计，互相隔离
迪米特法则 | 又称不知道原则， 功能模块尽量独立
合成复用原则 | 尽量使用聚合，组合，而不是继承

### 3.1 开闭原则（Open Close Principle）
>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
### 3.2 里氏代换原则（Liskov Substitution Principle）
>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
### 3.3 依赖倒转原则（Dependence Inversion Principle）
>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
### 3.4 接口隔离原则（Interface Segregation Principle）
>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
### 3.5 迪米特法则，又称最少知道原则（Demeter Principle）
>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
### 3.6 合成复用原则（Composite Reuse Principle）
>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

23种设计模式(GOF)：

# 创建型:(5)
* [__原型模式__](prototype.md) 不使用new关键字创建对象，而是通过对象复制来实现新对象的创建。

* [__工厂方法模式__](factory.md) 定义一个用于创建对象的接口，由子类决定实例化哪一个类，使一个类的实例化延迟到字类；一个产品对应一个子类工厂。
* [__抽象工厂__](abstract-factory.md) 为创建一组相关或相互依赖的对象的提供一个接口，且无需指定他们的具体类。
* [__单例模式__](singleton.md) 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
* 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不用的表示。


# 结构型:(7)
* 组合模式 将对象组合成树形结构以表示"部分－整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
* 享元模式 使用共享对象可有效地支持大量细粒度的对象。
* 代理模式 为某一对象提供一种代理以控制对这个对象的访问。
* 装饰器模式 动态地给一个对象增加一些额外的职责。比生成子类更加灵活。
* 外观模式  要求一个子系统的外部与内部的通信必须通过统一的对象进行。外观模式提供一个高层次的接口，使得子系统更易使用。
* 桥接模式 将抽象和实现解耦，使得两者可以独立变化。
* 适配器模式 将一个类的接口变换成客户端所期待的的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

 
#行为型:(11)
* [__迭代器模式__](iterator.md) 提供一种方法访问容器对象中的各个元素，而又不需要暴露该方法的内部细节。目前已经是一种没落的模式，基本上没人会单独写一个迭代器。
* 模板方法模式 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以在不改变一个算法的结构即可重定义该算法的某些特定实现。java中的继承覆盖。
* 解释器模式 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子，是一种按照规定语法进行解析的方案，在项目中使用较少。
* 命令模式 将一个请求封装成一个对象，从而可以使用不同的请求吧客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。
* 策略模式 定义一组算法，将每一个算法都封装起来，并且他们之间可以互相替换。
* [__责任链模式__](chain-responsibility.md) 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递给改请求，直到有对象处理它为止。
* 中介者模式 用一个中介对象封装一系列的对象交互，中介者使个对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
* 观察者模式 定义对象间一对多的依赖关系，是的每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。也叫发布订阅模式。
* 备忘录模式 在不破环封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可讲该对象恢复到原先保存的状态。
* 访问者模式 封装一些作用于某中数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
* 状态模式 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。